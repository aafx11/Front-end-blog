## MVVM模式
1. MVVM指的是数据驱动，它由 Model 模型层，负责业务逻辑和服务端进行交互，View 视图层，负责将数据模型转化成UI展示出来，
   以及 ViewModel 视图模型层，负责监听 Model 层中数据的改变并且控制视图的更新，以及处理用户在View 层的交互，是Model层和View之间的一个通信桥梁
2. 这种模式的优点就是 Model层 和 ViewModel层 之间是存在双向数据绑定的联系的，开发者可以专注于对数据的维护操作，而不需要自己操作dom节点，并且可以降低代码的耦合度，可以单独修改
   Model模型层 或者 View视图层
3. 缺点就是在调试bug的时候，当界面出现异常，可能是 View层 出现问题， 也可能是 Model层，难以对bug的原始位置进行定位

## MVC模式
1. MVC模式的思想是用 Controller控制器 负责将 Model层 的数据在 View层 里展示出来。
2. 是不存在双向数据绑定的关系的
## 组件化
1. 组件化就是视图和逻辑抽象成一个统一的概念，就是组件，在Vue开发中，每一个.vue文件都可以视为一个组件
2. 组件化降低了整个系统的耦合度，在保持接口不变的情况下，我们可以通过替换不同组件快速完成需求，
   比如输入框替换成日历，选项框等组件
3. 并且组件化更方便调试，由于整个系统是通过组件结合起来的，出了问题的时候，可以快速定位到报错的组件
4. 组件化也有利于提高项目的可维护性，每个组件的职责单一，并且组件能够在系统中被复用
   
## 指令系统
指令就是带有v-特殊前缀的属性，带有特定的作用，当表达式发生改变，就会响应式的作用于DOM节点上
常用的指令包括：
条件渲染v-if、v-show，列表渲染v-for，属性绑定v-bind，事件绑定v-on，双向绑定v-model
在没有指令之前，需要先获取dom在进行操作

## computed 和 watch 派生，缓存，表达式，监听，异步，选项，watchEffect
1. computed计算属性能够从组件数据中派生出新数据，最常见的用法就是设置一个函数，返回计算之后的结果，
   computed和methods的差异是它具备缓存性，如果依赖的数据不发生变化，就不会重新计算
   计算属性的使用场景通常是用来简化template模板中复杂的表达式，比如去计算一个动态的class类，去计算动态style
2. watch可以监听响应式数据的变化，并执行回调函数，watch没有返回值，但是可以执行异步操作等复杂逻辑，
   watch还可以设置deep，immediate等选项
   watch的使用场景是监听状态发生变化之后，进行一些dom操作或者异步操作
3. 在Vue3中出现了新的watchEffect，watchEffect并不需要指定某个具体的变量作为监听对象，而是自动收集回调函数中
   响应式变量的依赖，当依赖发生变化，重新执行回调函数（首次会自动执行）

## Vue2 和 Vue3的区别
1. 选项式api和组合式api
2. mixins 和 Hook
3. 还有性能上的提升
   （1）diff算法中增加了静态标记，被标记的静态节点，在diff过程中就不会参与比较，进一步提高性能
   （2）Vue3 中会对不参与更新的静态节点做静态提升，这个元素只会被创建一次，渲染的时候直接复用，  
   （3）打包体积的减小，Vue3的api是引入式的，只有被引入的api才会被打包（tree-shaking）
   （4）响应式系统的升级
4. 还有一些新的特性，Vue2的template只允许有一个根节点，Vue3是允许有多个根节点的，
   (当有多个根节点的时候，Vue3就会在最外层添加一个Fragment标签，包裹起来)
5. 还有像 Suspense 定义一个异步组件，自带两个 slot 分别为 default、fallback，
   当需要展示的组件还没加载完，Suspense就会展示 fallback 状态，当组件加载完就展示
   default状态，配合 defineAsyncComponent 加载异步组件
6. 提供了 teleport 组件，能够将包裹的组件渲染到指定的dom节点下，比如我们将模态框渲染到body标签下
   <Teleport to="body">
7. （TS）

## v-if 和 v-show 的区别
1. 控制手段不同
v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。 v-if显示隐藏是将dom元素整个添加或删除

2. 编译过程不同
v-if切换有一个局部编译/卸载的过程,切换过程中是会挂载或者销毁组件，是会触发生命周期的钩子函数的
v-show 只是基于css的视图切换

3. v-if是惰性的，当渲染条件为false时，是不会有任何操作被触发的
总的来说，v-if的性能消耗更大，他是直接操作dom节点的增加和删除
如果需要频繁切换，就用v-show，如果运行时，渲染条件很少改变就用v-if